Техническое задание
Пришло время потренироваться и усовершенствовать код трекера задач с помощью списков и хеш-таблиц! В этом спринте вам предстоит поработать над историей просмотров: сделать её неограниченной и избавиться от повторных просмотров в ней. А ещё вы добавите в приложение больше тестов. Поехали!
Подготавливаем ветку

В этом задании вы откажетесь от привычного процесса разработки в главной ветке. Теперь вы будете выполнять каждую проверочную работу в отдельной ветке.
Для выполнения задания текущего спринта создайте в локальном репозитории ветку с названием sprint_6-solution.
Продумываем реализацию

Вернёмся к трекеру задач! Итак, вам нужно:
Сделать историю посещений неограниченной по размеру.
Избавиться от повторных просмотров в истории. Если какую-либо задачу посещали несколько раз, то в истории должен остаться только её последний просмотр. Предыдущий должен быть удалён.
Недостаточно реализовать код таким образом, чтобы программа проходила по всей истории просмотров и только после этого удаляла предыдущий просмотр. Ведь тогда время работы этой программы будет линейно зависеть от длины истории.
Ваша цель — реализовать функциональность так, чтобы время просмотра задачи не зависело от общего количества задач в истории.
Интерфейс HistoryManager

В приложении уже есть интерфейс для управления историей просмотров — HistoryManager. Осталось добавить метод void remove(int id) для удаления задачи из просмотра и реализовать его в классе InMemoryHistoryManager. Добавьте вызов метода при удалении задач, чтобы они удалялись также из истории просмотров.
Подсказка: структура интерфейса HistoryManager
Дальнейшая разработка алгоритма со связным списком и HashMap

Программа должна запоминать порядок вызовов метода add, ведь именно в этом порядке просмотры будут выстраиваться в истории. Для хранения порядка вызовов удобно использовать список.
Если какая-либо задача просматривалась несколько раз, в истории должен отобразиться только последний просмотр. Предыдущий просмотр должен быть удалён сразу после появления нового — за O(1).
Из темы о списках вы узнали, что константное время выполнения операции может гарантировать связный список LinkedList. Однако эта стандартная реализация в данном случае не подойдёт: удалить элементы из списка можно по индексу или по значению с помощью методов remove, при этом на поиск удаляемого узла тратится время. Поэтому вам предстоит написать собственную реализацию связного списка с индексом по id задачи.
Вариант связного списка, который мы предлагаем реализовать, должен удалять элемент из произвольного места за O(1) с одним важным условием — программа уже знает нужное место в списке и сама управляет его узлами (в отличие от LinkedList).
Чтобы выполнить условие, создайте стандартную HashMap. Её ключом будет id задачи, просмотр которой требуется удалить, а значением — место просмотра этой задачи в списке, то есть узел связного списка. С помощью номера задачи можно получить соответствующий ему узел связного списка и удалить его.
Чтобы реализовать узел двусвязного списка, вспомните материал урока о LinkedList из темы о списках.

Реализация метода getHistory должна перекладывать задачи из связного списка в ArrayList для формирования ответа.
Подсказки

Подсказка 1
Вы уже знакомы с классом LinkedHashMap. Он представляет собой очень похожую реализацию контейнера, который сохраняет все полезные свойства LinkedList и добавляет к ним удобство индексации значений через интерфейс Map. Предлагаем вам реализовать аналог этого класса самостоятельно.
Подсказка 2
Сначала напишите свою реализацию двусвязного списка задач с методами linkLast и getTasks. linkLast будет добавлять задачу в конец этого списка, а getTasks — собирать все задачи из него в обычный ArrayList. Убедитесь, что решение работает. Отдельный класс для списка создавать не нужно — реализуйте его прямо в классе InMemoryHistoryManager. А вот отдельный класс Node для узла списка необходимо добавить.
Подсказка 3
Добавьте метод removeNode в класс InMemoryHistoryManager. В качестве параметра этот метод должен принимать объект Node — узел связного списка — и удалять его.
Подсказка 4
Создайте HashMap — будет достаточно её стандартной реализации. В ключах будут храниться id задач, а в значениях Node — узлы связного списка. Изначально HashMap пустая. Она будет заполняться по мере добавления новых задач. Напишите реализацию метода add(Task task). Теперь с помощью HashMap и метода удаления removeNode метод add(Task task) будет быстро удалять задачу из списка, если она там есть, а затем вставлять её в конец двусвязного списка. После добавления задачи не забудьте обновить значение узла в HashMap.
Совершенствуем unit-тесты

Поработайте над покрытием классов менеджера тестами. Отдельно протестируйте новую функциональность менеджера истории.
Скорректируйте предыдущие тесты под изменившийся алгоритм хранения версий задачи.
Проверьте, что встроенный связный список версий, а также операции добавления и удаления работают корректно.
Покройте тестами ещё несколько функций менеджера задач, которые вы реализовали в предыдущих спринтах. Отдельно уделите внимание целостности данных:
Внутри эпиков не должно оставаться неактуальных id подзадач.
С помощью сеттеров экземпляры задач позволяют изменить любое своё поле, но это может повлиять на данные внутри менеджера. Протестируйте эти кейсы и подумайте над возможными вариантами решения проблемы.
Дополнительное задание. Реализуем пользовательский сценарий

Если у вас останется время, вы можете выполнить дополнительное задание. Реализуйте в классе Main опциональный пользовательский сценарий:
Создайте две задачи, эпик с тремя подзадачами и эпик без подзадач.
Запросите созданные задачи несколько раз в разном порядке.
После каждого запроса выведите историю и убедитесь, что в ней нет повторов.
Удалите задачу, которая есть в истории, и проверьте, что при печати она не будет выводиться.
Удалите эпик с тремя подзадачами и убедитесь, что из истории удалился как сам эпик, так и все его подзадачи.
Обратите внимание, что выполнение этого задания необязательно.
Интересного вам программирования!